apply plugin: 'java'
apply plugin: 'eclipse'

version = '1.1.0'

repositories {
  mavenLocal()
  mavenCentral()
  maven {
    url "$nexusBaseUrl/repositories/releases"
    credentials {
      username nexusUserName
      password nexusPassword
    }
  }
}

buildscript {
  repositories { mavenCentral() }
  dependencies {
    classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
    classpath 'com.typesafe:config:1.2.0'
  }
}

configurations {
  // configuration used by plugins to enumerate jars that need to be added to the distribution zip
  distBundle
}

dependencies {
  compile 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
  // snapshot for testing
  compile 'com.xebialabs.deployit:engine-api:4.0.1-SNAPSHOT'
  // alpha for testing
  compile 'com.xebialabs.deployit:engine-api:4.1.0-alpha-1'

  // 
  distBundle 'com.xebialabs.deployit:engine-api:4.0.1-SNAPSHOT'
  // alpha for testing
  distBundle 'com.xebialabs.deployit:engine-spi:4.1.0-alpha-1'
}

gradle.taskGraph.whenReady { taskGraph ->
  // append snapshot for non release builds
  if (!taskGraph.hasTask(':release')) {
    version += '-SNAPSHOT'
  }
  // TODO: for alpha we could append alpha and read the alpha number from a file
}

task distribution << {
  println "Building distribution (pretend)"
}

task checkRepositoryIsClean(type: CheckRepoClean ) {
  description = 'Check that the git repository is clean.'
  dryRun = true
  group = 'Verification'
  gitDir = project.file(project.rootProject.projectDir.path + "/.git")
   if (!gitDir.exists()) {
    throw GradleException("Cannot release from a non version controlled tree.")
  }
}

task checkNoSnapshotDependencies(type: CheckConfiguration) {
  configuration = configurations.compile
}

task release {
  group = 'Release'
  description = "Do a release."
  // distribution task must be configurable since it's named differently in deployit/package project
  dependsOn build, distribution, checkRepositoryIsClean, checkNoSnapshotDependencies
  doFirst {
    // could do repo clean check also in doFirst, has benefit that we can do all the checks and then abort
    // in stead of failing at the first check task
  }
  doLast {

  }
}

import org.eclipse.jgit.api.Git
import org.eclipse.jgit.storage.file.FileRepository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

class CheckRepoClean extends DefaultTask {
  File gitDir
  boolean dryRun = false

  @TaskAction
  def checkClean() {
    FileRepository repo = new FileRepositoryBuilder().setGitDir(gitDir).build()

    def status = new Git(repo).status().call()
    if (!status.isClean()) {
      if(dryRun) {
        println("The repo ${repo} is not clean. Please commit all changes before doing a release.")
      } else {
        throw new IllegalStateException("The repo ${repo} is not clean. Please commit all changes before doing a release.")
      }
    }
  }
}

class CheckConfiguration extends DefaultTask {
  // TODO do we need a list of configurations ?
  Configuration configuration

  @TaskAction
  def checkArtifacts() {
    logger.info("Checking configuration $configuration")
    configuration.resolvedConfiguration.resolvedArtifacts.each { ResolvedArtifact artifact ->
      int errors = 0
      def version = artifact.moduleVersion.id.version
      def name = artifact.moduleVersion.id.name
      def group = artifact.moduleVersion.id.group
      // println "Checking $name:$version"
      if( version ==~ /.*alpha.*/ || version ==~ /.*SNAPSHOT.*/ ) {
        errors++
        // TODO include classifier
        logger.error("Found non release dependency ${group}:${name}:${version}")
      }
    }
    if(errors > 0) {
      throw new GradleException("Invalid artifact dependencies found")
    }
  }
}

import org.eclipse.jgit.api.Git
import org.eclipse.jgit.storage.file.FileRepository
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class ReleasePluginPlugin implements Plugin<Project> {
    private static final Logger log = LoggerFactory.getLogger(ReleasePluginPlugin.class)

    enum ReleaseVersion { ALPHA, BETA, RELEASE }

    private Git repo
    private String versionString
    private Project rootProject
    private ReleaseVersion releaseVersion

    @Override
    void apply(Project project) {
        log.warn("Applying ReleasePluginPlugin to " + project.name)
        if (!project.tasks.names.containsAll(["clean", "build", "uploadArchives", "uploadDocumentation"])) {
            println "Cannot apply releases-plugin to " + project.name +
                    ": tasks [clean, build, uploadArchives, uploadDocumentation] must all be present"
            return
        }

        def release_task = project.rootProject.tasks.create("release")
        release_task.configure {
            this.rootProject = project.rootProject
            this.releaseVersion =
                    project.hasProperty("alpha") ? ReleaseVersion.ALPHA :
                    project.hasProperty("beta") ? ReleaseVersion.BETA :
                    project.hasProperty("final") ? ReleaseVersion.RELEASE :
                    null
            log.info("Release version ${releaseVersion} requested")
            release_task.doLast {
                if (!releaseVersion) {
                    println "What kind of release do you want? Please specify -Palpha, -Pbeta, or -Pfinal"
                    return
                }
                log.warn("releaseVersion: ${releaseVersion.name()}")
                doRelease()
            }
        }
    }

    def doRelease() {
        def rootDir = this.rootProject.rootDir
        log.warn("Using git repo at ${rootDir}")
        repo = Git.open(rootDir)
        ensureCleanRepo()
        gitPullRebase()
        setProjectVersion()
        doUpload project
        gitCommitAndTagReleasedVersion()
        bumpProjectVersion()
        gitCommitNextVersion()
        gitPush()
    }

    def ensureCleanRepo() {
        if (!(repo.status().call().clean)) {
            throw new GradleException("You have outstanding work. Please commit or stash before releasing.")
        }
    }

    def gitPullRebase() {
        try {
            repo.pull().setRebase(true).call()
        } catch (Exception e) {
            throw new GradleException("git pull --rebase failed", e)
        }
    }

    def setProjectVersion() {
        // TODO!
        // this.versionString = sump'n'sump'n'.
    }

    def doUpload() {
        this.rootProject.task("clean").execute()
        this.rootProject.task("build").execute()
        this.rootProject.task("uploadArchives").execute()
        this.rootProject.task("uploadDocumentation").execute()
    }

    def gitCommitAndTagReleasedVersion(Git repo) {
        def version = "${this.rootProject.name}-${versionString}"
        try {
            repo.commit().setMessage("Releasing ${version}").call()
            repo.tag().setMessage(version)
        } catch(Exception e) {
            throw new GradleException("git commit or git tag failed", e)
        }
    }

    def bumpProjectVersion() {
        // TODO!
    }

    def gitCommitNextVersion() {

    }
}

apply plugin: ReleasePluginPlugin